---
title: MeshMultiZoneService
description: Group MeshServices across zones into a single multi-zone service with zone-agnostic hostnames and load balancing.

content_type: reference
layout: reference
products:
    - mesh
breadcrumbs:
  - /mesh/

related_resources:
  - text: Policy Hub
    url: /mesh/policies/
  - text: DNS
    url: /mesh/dns/
  - text: Resource sizing guidelines
    url: /mesh/resource-sizing-guidelines/
  - text: Version compatibility
    url: /mesh/version-compatibility/
  - text: Zone ingress
    url: /mesh/zone-ingress/
  - text: Zone egress
    url: /mesh/zone-egress/

min_version:
    mesh: '2.9'
---

The MeshMultiZoneService resource represents a group of MeshServices in a multi-zone deployment.

MeshMultiZoneService is assigned zone-agnostic hostnames and can load balance the traffic to multiple MeshServices.
For example, a MeshService named `redis` in zone `east` accessible through `redis.svc.east.mesh.local` and a MeshService named `redis` in zone `west`
accessible through `redis.svc.west.mesh.local` can be aggregated into one MeshMultiZoneService accessible through `redis.mzsvc.mesh.local`.

The most common use case for using MeshMultiZoneService is to group MeshServices that spawn across multiple clusters with failover to another cluster in case of unavailability in the local cluster.

Contrary to MeshService, MeshMultiZoneService is not autogenerated, it has to be defined on the global control plane.

To group services, you need to select them by their labels. Each MeshService has a set of labels. Some of them are added automatically:
* `kuma.io/display-name`: The original name of the MeshService from the zone where it was created.
* `k8s.kuma.io/namespace`: The original namespace of the MeshService from the zone where it was created.

Here's an example of the MeshMultiZoneService configuration:

{% policy_yaml %}
```yaml
type: MeshMultiZoneService
name: redis
mesh: default
spec:
  selector:
    meshService:
      matchLabels:
        kuma.io/display-name: redis
        k8s.kuma.io/namespace: redis-system
  ports:
    - port: 6379
      appProtocol: tcp
```
{% endpolicy_yaml %}

The MeshMultiZoneService represents a destination for traffic from elsewhere in the mesh.
It defines which MeshService objects serve this traffic as well as what ports are available.
It also holds information about which IPs and hostnames can be used to reach this destination.

## Hostnames and VIPs

[HostnameGenerator](/mesh/hostnamegenerator/) can be used to assign hostnames.

{{site.mesh_product_name}} assigns each MeshMultiZoneService a unique Virtual IP.
The default CIDR is `243.0.0.0/8` and can be changed by [configuring a zone control plane](/mesh/control-plane-configuration/) with the `KUMA_IPAM_MESH_MULTI_ZONE_SERVICE_CIDR` environment variable.

Hostnames and VIPs are assigned and stored in the MeshMultiZoneService status in each zone.
It means that you won't be able to see them in the status of the MeshMultiZoneService in the global control plane GUI.

## Ports

The `ports` field lists the ports exposed by the MeshService that the MeshMultiZoneService matches:

```yaml
ports:
- name: redis-non-tls
  port: 16739
  appProtocol: tcp
```

## Load balancing

If available, the local zone is always preferred when a client sends a request.
Otherwise, the request is load balanced equally for each zone. You can customize this behavior with the [MeshLoadBalancingStrategy](/mesh/policies/meshloadbalancingstrategy/) policy, by targeting MeshMultiZoneService in the [`to` section](/mesh/policies/meshloadbalancingstrategy/reference/#schema--to).

## MeshMultiZoneService configuration

{% json_schema MeshMultiZoneServices %}
